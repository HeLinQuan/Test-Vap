C51 COMPILER V9.00   RS485                                                                 04/18/2024 20:31:04 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE RS485
OBJECT MODULE PLACED IN .\Output\RS485.obj
COMPILER INVOKED BY: F:\KEIL5\C51\BIN\C51.EXE ..\..\Application\RS485-Modbus\RS485.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\
                    -..\Application;..\..\User\INC;..\..\Libraries;..\..\Application\Buzzer_Driver;..\..\Application;..\..\Application\DISPLA
                    -Y;..\..\Application\TM1652;..\..\Application\WDT;..\..\Application\TIMER;..\..\Application\EEPROM_R_W;..\..\Application\
                    -AD_WORK;..\..\Application\Fun_Handle;..\..\Application\KEY;..\..\Application\USART;..\..\Application\RS485-Modbus) DEBUG
                    - OBJECTEXTEND PRINT(.\List\RS485.lst) OBJECT(.\Output\RS485.obj)

line level    source

   1          /*
   2          Ê¹ÓÃËµÃ÷
   3          1£ºÅäºÏ¸Ã¹¤³ÌÏÂµÄ´®¿Ú³õÊ¼»¯
   4          void UartInit()                 //uart³õÊ¼»¯
   5          {
   6              P1M6 = GPIO_Out_PP ;      //RXD      ÉèÖÃÎªÉÏÀ­ÊäÈë
   7                  P1M7 = GPIO_In_PU ;    // TXD       ÉèÖÃÎªÍÆÍìÊä³ö
   8                  
   9                  TXD_MAP =0x16 ;                                                 //TXDÓ³ÉäP
  10                  RXD_MAP =0x17 ;                                                 //RXDÓ³ÉäP
  11              
  12                  T4CON = 0x06;                                                           //T4¹¤×÷Ä£Ê½£ºUART1²¨ÌØÂÊ·¢ÉúÆ÷
  13          
  14              TH4 = 0xFF;
  15                  TL4 = 0x98;                                                     //²¨ÌØÂÊ9600
  16                  SCON2 = 0x02;                                           //8Î»UART£¬²¨ÌØÂÊ¿É±ä
  17                  SCON = 0x10;                                            //ÔÊÐí´®ÐÐ½ÓÊÕ
  18                  IE |= 0x10;                                                     //Ê¹ÄÜ´®¿ÚÖÐ¶Ï
  19                  EA = 1;                                                           //Ê¹ÄÜ×ÜÖÐ¶Ï
  20          }
  21          
  22          2£ºÔÚ´®¿ÚÖÐ¶ÏÖÐ½ÓÊÕ´«»ØµÄÊý¾Ý
  23          void UART1_Rpt(void) interrupt UART1_VECTOR
  24          {
  25                  if(SCON&0x01)                                           //ÅÐ¶Ï½ÓÊÕÖÐ¶Ï±êÖ¾Î»
  26                  {
  27                                  SCON &=~ 0x01;                                  //Çå³ý½ÓÊÕÖÐ¶Ï±êÖ¾Î»
  28                      if(USE_RS485 == 0)
  29                      {
  30                          Receiveflag = 1;
  31                          Receietime = 0;
  32                          ReceivebeBuffer[Receivenum] = SBUF;
  33                          Receivenum++;
  34                      }
  35                      else
  36                      {
  37                          if(USART_RX_CNT < USART_RX_MAX)  //½ÓÊÕµ½µÄ×Ö½Ú Ð¡ÓÚ ÉèÖÃµÄ×î´ó»º´æÇø
  38                          {
  39                              USART_RX_CNT++;
  40                              USART_RX_BUF[USART_RX_CNT] = SBUF;
  41                          }
  42                      }
  43                                  
  44                  }       
  45          }
  46          
  47          3£º¶¨Ê±Æ÷É¨Ãè£¬Ò»Ö¡½áÊøÅÐ¶Ïº¯Êý
  48          static void Scan_1ms(void)
  49          {
  50              if(F_1MS==1)
  51                  {
C51 COMPILER V9.00   RS485                                                                 04/18/2024 20:31:04 PAGE 2   

  52                  F_1MS = 0;
  53                  UartRxMonitor();
  54              }
  55          }
  56          
  57          
  58          */
  59          #include "define.h"
  60          
  61          u8       USART_RX_CNT = 0;             //´®¿ÚÖÐ¶Ï½ÓÊÕµ½Êý¾ÝµÄ³¤¶È±äÁ¿
  62          u8 xdata USART_RX_BUF[USART_RX_MAX];   //´®¿ÚÖÐ¶Ï½ÓÊÕµ½Êý¾Ý±£´æµÄ»º³åÇø
  63          bit      F_ReceiveOk = 0;              //±êÊ¶´®¿Ú½ÓÊÕÊý¾Ý°üÍê³É±êÖ¾
  64          
  65          bit RS485Busy = 0;  //Í¨ÐÅ±êÊ¶ Ö÷»ú·¢ËÍÊý¾ÝºóÖÃ1 ½ÓÊÕµ½Ó¦´ðºóÇåÁã
  66          u8 xdata RS485_RX_BUF[64];  //½ÓÊÕ»º³åÇø 64×Ö½Ú
  67          u16 ReadDateVal = 0;  //ÓÃÓÚ±£´æ¶ÁÃüÁî»ñµÃµÄÊý¾Ý
  68          u8 RegGroup[5];       //Modbus¼Ä´æÆ÷Êý×é£¬µØÖ·Îª 0X00--0X04
  69          
  70          void RS485_Init(void)   //485´®¿Ú³õÊ¼»¯
  71          {
  72   1          /*Ê¹ÓÃÍ¨ÓÃ´®¿Ú USART ÖÐµÄ RXD Óë TXD ÔÚ´Ë´¦²»ÓÃ³õÊ¼»¯*/
  73   1          
  74   1          RS485_MODE_Receive     //Ä¬ÈÏÎ»½ÓÊÕÄ£Ê½
  75   1      }
  76          
  77          /****************************************************************************************************
  78           * º¯ÊýÃû³Æ£º void RS485_SendData(u8 *buf,u8 len)
  79           * Èë¿Ú²ÎÊý£ºu8 *buf u8 len
  80           * ·µ»Ø  Öµ£ºÎÞ
  81           * ¹¦ÄÜËµÃ÷£º´®¿Ú·¢ËÍÊý¾Ý
  82           *                       buf:·¢ËÍÇøÊ×µØÖ·
  83           *                       len:·¢ËÍµÄ×Ö½ÚÊý(ÎªÁËºÍ±¾´úÂëµÄ½ÓÊÕÆ¥Åä,ÕâÀï½¨Òé²»Òª³¬¹ý64¸ö×Ö½Ú)
  84           ***************************************************************************************************/
  85          void RS485_SendData(u8 *buf,u8 len)
  86          {
  87   1              u8 t;
  88   1              RS485_MODE_Sending                      //ÉèÖÃÎª·¢ËÍÄ£Ê½
  89   1              delay_ms(1);
  90   1              for(t=0;t<len;t++)              //Ñ­»··¢ËÍÊý¾Ý
  91   1              {       
  92   2              SBUF = *(buf+t);
  93   2                      while(!TI);
  94   2              TI = 0;
  95   2              }        
  96   1              delay_ms(1);                    //IO×ª»»ÉÔ×÷ÑÓÊ±
  97   1              USART_RX_CNT=0;   
  98   1              RS485_MODE_Receive                      //ÉèÖÃÎª½ÓÊÕÄ£Ê½        
  99   1      }
 100          /****************************************************************************************************
 101           * º¯ÊýÃû³Æ£ºu8 RS485_ReadData(u8 *buf, u8 len) 
 102           * Èë¿Ú²ÎÊý£ºu8 *buf u8 len
 103           * ·µ»Ø  Öµ£ºu8
 104           * ¹¦ÄÜËµÃ÷£º¼ÆËã½ÓÊÕµÄÊý¾Ý³¤¶È£¬²¢ÇÒ½«Êý¾Ý·Åµ½*bufÊý×éÖÐ
 105           ***************************************************************************************************/     
             -        
 106          u8 RS485_ReadData(u8 *buf, u8 len)    //USART_RX_CNT ¡¢ len ÓÐbug
 107          {
 108   1              u8 i;
 109   1              if(len > USART_RX_CNT)                  //Ö¸¶¨¶ÁÈ¡³¤¶È´óÓÚÊµ¼Ê½ÓÊÕµ½µÄÊý¾Ý³¤¶ÈÊ±
 110   1              {
 111   2                      len = USART_RX_CNT;             //¶ÁÈ¡³¤¶ÈÉèÖÃÎªÊµ¼Ê½ÓÊÕµ½µÄÊý¾Ý³¤¶È
 112   2              }
C51 COMPILER V9.00   RS485                                                                 04/18/2024 20:31:04 PAGE 3   

 113   1              
 114   1              for(i = 0;i < len;i ++)                 //¿½±´½ÓÊÕµ½µÄÊý¾Ýµ½½ÓÊÕÖ¸ÕëÖÐ
 115   1              {
 116   2                      *buf = USART_RX_BUF[i];         //½«Êý¾Ý¸´ÖÆµ½bufÖÐ
 117   2                      buf  ++;
 118   2              }
 119   1              USART_RX_CNT=0;                 //½ÓÊÕ¼ÆÊýÆ÷ÇåÁã
 120   1              return len;                     //·µ»ØÊµ¼Ê¶ÁÈ¡³¤¶È
 121   1      }
 122          
 123          /****************************************************************************************************
 124           * º¯ÊýÃû³Æ£ºvoid UartRxMonitor(void)
 125           * Èë¿Ú²ÎÊý£ºvoid
 126           * ·µ»Ø  Öµ£ºÎÞ
 127           * ¹¦ÄÜËµÃ÷£ºÔÚ¶¨Ê±Æ÷ÖÐµ÷ÓÃ£¬ÓÃÓÚ¼à¿ØÊý¾Ý½ÓÊÕ  1ms É¨ÃèÒ»´Î
 128           ***************************************************************************************************/   
 129          void UartRxMonitor(void)                                        
 130          {
 131   1              static u8 USART_RX_BKP = 0;                     //¶¨ÒåUSART2_RC_BKPÔÝÊ±´æ´¢Ê«¾ä³¤¶ÈÓëÊµ¼Ê³¤¶È±È½Ï
 132   1              static u8 idletmr      = 0;                     //¶¨Òå¼à¿ØÊ±¼ä
 133   1              
 134   1              if(USART_RX_CNT > 0)                                    //½ÓÊÕ¼ÆÊýÆ÷´óÓÚÁãÊ±£¬¼à¿Ø×ÜÏß¿ÕÏÐÊ±¼ä
 135   1              {
 136   2                      if(USART_RX_BKP != USART_RX_CNT)        //½ÓÊÕ¼ÆÊýÆ÷¸Ä±ä£¬¼´¸Õ½ÓÊÕµ½Êý¾ÝÊ±£¬ÇåÁã¿ÕÏÐ¼ÆÊ±
 137   2                      {
 138   3                              USART_RX_BKP = USART_RX_CNT;    //¸³Öµ²Ù×÷£¬½«Êµ¼Ê³¤¶È¸øUSART2_RX_BKP
 139   3                              idletmr      = 0;               //½«¼à¿ØÊ±¼äÇåÁã
 140   3                      }
 141   2                      else                                    //½ÓÊÕ¼ÆÊýÆ÷Î´¸Ä±ä£¬¼´×ÜÏß¿ÕÏÐÊ±£¬ÀÛ¼Æ¿ÕÏÐÊ±¼ä
 142   2                      {
 143   3                                                                                              //Èç¹ûÔÚÒ»Ö¡Êý¾ÝÍê³ÉÖ®Ç°ÓÐ³¬¹ý3--5¸ö×Ö½ÚÊ±¼äµÄÍ£¶Ù£¬½ÓÊÕÉè±¸½«Ë¢ÐÂµ±Ç°µÄÏûÏ¢²¢¼Ù¶¨ÏÂÒ»¸ö×Ö½ÚÊÇÒ
             -»¸öÐÂµÄÊý¾ÝÖ¡µÄ¿ªÊ¼
 144   3                              if(idletmr < 3)                 //¿ÕÏÐÊ±¼äÐ¡ÓÚ3msÊ±£¬³ÖÐøÀÛ¼Ó
 145   3                              {
 146   4                                      idletmr++;
 147   4                                      if(idletmr >= 5)            //¿ÕÏÐÊ±¼ä´ïµ½5msÊ±£¬¼´ÅÐ¶¨Îª1Ö¡½ÓÊÕÍê±Ï
 148   4                                      {
 149   5                                              F_ReceiveOk = 1;                        //ÉèÖÃÃüÁîµ½´ï±êÖ¾£¬Ö¡½ÓÊÕÍê±Ï±êÖ¾
 150   5                                      }
 151   4                              }
 152   3                      }
 153   2              }
 154   1              else
 155   1              {
 156   2                      USART_RX_BKP = 0;
 157   2              }
 158   1      }
 159          
 160          /****************************************************************************************************
 161           * º¯ÊýÃû³Æ£ºvoid UartRxMonitor(u8 ms)
 162           * Èë¿Ú²ÎÊý£ºu8 ms
 163           * ·µ»Ø  Öµ£ºÎÞ
 164           * ¹¦ÄÜËµÃ÷£º´®¿ÚÇý¶¯º¯Êý£¬¼ì²âÊý¾ÝÖ¡µÄ½ÓÊÕ£¬µ÷¶È¹¦ÄÜº¯Êý£¬ÐèÔÚÖ÷Ñ­»·ÖÐµ÷ÓÃ
 165           *           ÕâÀïÊÇ´Ó»ú£¬ÐèÒª¶ÔÖ÷»ú·¢À´µÄ±¨ÎÄ½øÐÐ¶ÔÓ¦µÄ´¦Àí£¬²¢·µ»ØÓ¦´ð
 166           *                       ´Ó»ú²»Ö÷¶¯·¢ËÍÊý¾Ý£¬Ò»ÇÐ²Ù×÷¶¼ÊÇÎªÁËÏìÓ¦Ö÷»úµÄ±¨ÎÄ
 167           ***************************************************************************************************/   
 168          void UartDriver(void)
 169          {
 170   1              unsigned char xdata i;
 171   1              unsigned char xdata cnt;
 172   1              
 173   1              unsigned int xdata crc;
C51 COMPILER V9.00   RS485                                                                 04/18/2024 20:31:04 PAGE 4   

 174   1              unsigned char xdata crch,crcl;
 175   1              static unsigned char xdata len;
 176   1              static unsigned char xdata buf[USART_RX_MAX];
 177   1              if (F_ReceiveOk)                                                                                //Ö¡½ÓÊÕÍê³É±êÖ¾£¬¼´½ÓÊÕµ½Ò»Ö¡ÐÂÊý¾Ý
 178   1              {
 179   2                      F_ReceiveOk = 0;                                                                        //Ö¡½ÓÊÕÍê³É±êÖ¾ÇåÁã
 180   2                      len = RS485_ReadData(buf,USART_RX_CNT);                                 //½«½ÓÊÕµ½µÄÃüÁî¶Áµ½»º³åÇøÖÐ
 181   2                      crc = GetCRC16(buf,len-2);                                              //¼ÆËãCRCÐ£ÑéÖµ£¬³ýÈ¥CRCÐ£ÑéÖµ
 182   2                      crch=crc  >> 8;                                                                                 //crc¸ßÎ»
 183   2                      crcl=crc  &  0xFF;                                                                              //crcµÍÎ»
 184   2                      if((buf[len-2] == crch) && (buf[len-1] == crcl))                //ÅÐ¶ÏCRCÐ£ÑéÊÇ·ñÕýÈ·
 185   2                      {
 186   3                              /* ÔÚµã¶Ô¶àµãµÄÓ¦ÓÃÖÐ£¬ÕâÀï»¹ÐèÒª¼ÓÉÏÒ»Ìõ£¬ÅÐ¶Ï±¨ÎÄµÄµØÖ·ÊÇ·ñºÍ±¾»úµØÖ·Ò»ÖÂ£¬·ñÔò²»×÷´¦Àí */
 187   3                              /* ¿ÉÉèÖÃ²»Í¬´Ó»úÎª²»Í¬µØÖ·£¬ÓÃÒÔÇø·Ö±¨ÎÄÊÇ·¢¸øË­µÄ£¬ÏàÍ¬Ôò´¦Àí£¬²»Í¬Ôò²»×÷´¦Àí */
 188   3                              switch (buf[1])                                                                         //°´¹¦ÄÜÂëÖ´ÐÐ²Ù×÷
 189   3                              {
 190   4                                      case 0x03:                                                                      //¶ÁÊý¾Ý
 191   4                                              if((buf[2] == 0x00) && (buf[3] <= 0x05))        //¼Ä´æÆ÷µØÖ·Ö§³Ö0x0000~0x0005
 192   4                                              {
 193   5                                                      if(buf[3] <= 0x04) 
 194   5                                                      {
 195   6                                                              i      = buf[3];                                        //ÌáÈ¡¼Ä´æÆ÷µØÖ·
 196   6                                                              cnt    = buf[5];                                        //ÌáÈ¡´ý¶ÁÈ¡µÄ¼Ä´æÆ÷ÊýÁ¿
 197   6                                                              buf[2] = cnt*2;                                         //¶ÁÈ¡Êý¾ÝµÄ×Ö½ÚÊý£¬Îª¼Ä´æÆ÷*2£¬Òòmodbus¶¨ÒåµÄ¼Ä´æÆ÷Îª16Î»
 198   6                                                              len    = 3;                                                     //ÏìÓ¦Ö¡µÚ4¸ö×Ö½Ú¿ªÊ¼ÎªÊý¾Ý
 199   6                                                              while(cnt --)
 200   6                                                              {
 201   7                                                                      buf[len ++] = 0x00;                             //¼Ä´æÆ÷¸ß×Ö½Ú²¹0
 202   7                                                                      buf[len ++] = RegGroup[i++];    //µÍ×Ö½Ú
 203   7                                                              }
 204   6                                                      }
 205   5                                                      break;
 206   5                                              }
 207   4                                              else                                                                            //¼Ä´æÆ÷µØÖ·²»±»Ö§³ÖÊ±£¬·µ»Ø´íÎóÂë
 208   4                                              {   
 209   5                                                      buf[1] = 0x83;                                                  //¹¦ÄÜÂë×î¸ßÎ»ÖÃ1
 210   5                                                      buf[2] = 0x02;                                                  //ÉèÖÃÒì³£ÂëÎª02-ÎÞÐ§µØÖ·
 211   5                                                      len    = 3;
 212   5                                                      break;
 213   5                                              }
 214   4                                      case 0x06:                                                              //Ð´Èëµ¥¸ö¼Ä´æÆ÷
 215   4                                              if((buf[2] == 0x00) && (buf[3] <= 0x05))        //¼Ä´æÆ÷µØÖ·Ö§³Ö0x0000-0x0005
 216   4                                              {
 217   5                                                      if(buf[3] <= 0x04)
 218   5                                                      {
 219   6                                                              i           = buf[3];                           //ÌáÈ¡¼Ä´æÆ÷µØÖ·
 220   6                                                              RegGroup[i] = buf[5];                           //±£´æ¼Ä´æÆ÷Êý¾Ý
 221   6                                                      }
 222   5                                                      len -= 2;                                               //³¤¶È-2ÒÔÖØÐÂ¼ÆËãCRC²¢·µ»ØÔ­±¨ÎÄ
 223   5                                                      break;
 224   5                                              }
 225   4                                              else  
 226   4                                              {                                                                                       //¼Ä´æÆ÷µØÖ·²»±»Ö§³Ö£¬·µ»Ø´íÎóÂë
 227   5                                                      buf[1] = 0x86;                                          //¹¦ÄÜÂë×î¸ßÎ»ÖÃ1
 228   5                                                      buf[2] = 0x02;                                          //ÉèÖÃÒì³£ÂëÎª02-ÎÞÐ§µØÖ·
 229   5                                                      len    = 3;
 230   5                                                      break;
 231   5                                              }
 232   4                                      default:                                                                                //ÆäËû²»Ö§³ÖµÄ¹¦ÄÜÂë
 233   4                                              buf[1] = 0x80;                                                          //¹¦ÄÜÂë×î¸ßÎ»ÖÃ1
 234   4                                              buf[2] = 0x01;                                                          //ÉèÖÃÒì³£ÂëÎª01¡ªÎÞÐ§¹¦ÄÜ
 235   4                                              len    = 3;
C51 COMPILER V9.00   RS485                                                                 04/18/2024 20:31:04 PAGE 5   

 236   4                                              break;
 237   4                              }
 238   3                              crc = GetCRC16(buf,len);                                                //¼ÆËãCRCÐ£ÑéÖµ
 239   3                              buf[len ++] = crc >> 8;                                                 //CRC¸ß×Ö½Ú
 240   3                              buf[len ++] = crc & 0xff;                                               //CRCµÍ×Ö½Ú
 241   3                              RS485_SendData(buf,len);                                                                //·¢ËÍÏìÓ¦Ö¡
 242   3                      }
 243   2                      //else  /* Èç¹ûÐ£ÑéÖµ´íÎó£¬Ö´ÐÐ´íÎó´¦Àíº¯Êý ÕâÀïÓÃ´®¿Ú1´òÓ¡Ò»ÌõÌáÊ¾ÐÅÏ¢ Ò²¿É×Ô¶¨Òå¹²Ëü´¦Àíº¯Êý */
 244   2                              //printf("½ÓÊÕ´íÎó\r\n");
 245   2              }
 246   1      }
 247          
 248          
 249          
 250          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    556    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    193       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
